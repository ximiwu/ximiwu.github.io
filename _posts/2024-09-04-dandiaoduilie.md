---
layout:     post
title:      "DP优化：单调队列三题"
subtitle:   ""
date:       2024-09-04 15:00:00
author:     "西米屋花火"
catalog: true
header-img: "img/post-nana.jpg"
header-mask: 0.5
tags:
    - 动态规划
    - 线性DP
    - 单调队列
    - DP优化
    - 算法
---

## 引入：最大子序和

输入一个长度为n的整数序列，从中找出一段不超过m的连续子序列，使得整个序列的和最大。\
例如 1,-3,5,1,-2,3\
当m=4时，S=5+1-2+3=7\
当m=2或m=3时，S=5+1=6

## 输入描述:

    第一行两个数n,m（n,m≤300000）（n,m <= 300000）（n,m≤300000）  
    第二行有n个数，要求在n个数找到最大子序和

## 输出描述:

    一个数，数出他们的最大子序和

示例1

## 输入

    6 4
    1 -3 5 1 -2 3

## 输出

    7

## 思路

#### 朴素做法

*   遍历序列，以序列每个元素为起点，依次枚举长度为1、2、...m的子序列和

#### 单调队列优化

##### 原理：

*   改用前缀和（记为s）的方法求子序列和，i到j子序和(i > j)：s\[i] - s\[j - 1]
*   遍历序列，以序列每个元素为子序列终点，对应前缀和记为s\[i]
*   利用单调队列获得长度不超过m的子序列和最大值
*   即通过单调队列获得从s\[i - m]到s\[i]中最小值

##### 单调队列维护：

*   每次遍历下一个序列元素前，将当前元素加入到单调队列中
*   把单调队列中所有大于当前元素的都删掉，再把当前元素加到队列尾
*   通过这样维护，单调队列自然就是单调递增的，队列头最小，队列尾最大
*   注意单调队列中存的是下标

## 题解

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, m;

const int MAXN = 3e5 + 10;
//存储前缀和
int s[MAXN];

//单调队列的头和尾
//head比tail小，表示队列为空
//注：作者在写这段代码时想象的head在左，tail在右，head不可延申，tail可向右延申
int head = -1;
int tail = 0;
//单调队列存储s的下标
int q[MAXN];

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; ++i) {
        cin >> s[i];
        s[i] += s[i - 1];
    }

    int res = 0;
    //和朴素做法一样，都需要遍历一遍序列
    for(int i = 1; i <= n; ++i) {
        //子序列长度不超过m
        if(q[tail] < i - m) tail += 1;
        res = max(res, s[i] - s[q[tail]]);
        //去掉队列中所有比s[i]大的项
        //注意tail大于head时要停止，此时队列为空，q[head]失去实际意义
        while(head >= tail && s[q[head]] >= s[i]) head -= 1;
        //再将s[i]加入队列，实现单调队列的维护
        q[++head] = i;
    }

    cout << res;

}
```

## 应用1：\[POI 2004] 旅行问题

John 打算驾驶一辆汽车周游一个环形公路。公路上总共有 n 车站，每站都有若干升汽油（有的站可能油量为零），每升油可以让汽车行驶一千米。John 必须从某个车站出发，一直按顺时针（或逆时针）方向走遍所有的车站，并回到起点。在一开始的时候，汽车内油量为零，John 每到一个车站就把该站所有的油都带上（起点站亦是如此），行驶过程中不能出现没有油的情况。

任务：判断以每个车站为起点能否按条件成功周游一周。

## 输入格式

第一行是一个整数 n，表示环形公路上的车站数；

接下来 n 行，每行两个整数 p\_i,d\_i，分别表示表示第 i 号车站的存油量和第 i 号车站到下一站的距离。

## 输出格式

输出共 n 行，如果从第 i 号车站出发，一直按顺时针（或逆时针）方向行驶，能够成功周游一圈，则在第 i 行输出 `TAK`，否则输出 `NIE`。

## 样例

输入

    5
    3 1
    1 2
    5 2
    0 1
    5 4

输出

    TAK
    NIE
    TAK
    NIE
    TAK

数据范围与提示

对于全部数据，3<= n<= 10^6, 0<= p\_i<= 2\* 10^9, 0< d\_i<= 2\* 10^9。

## 思路

#### 环形

*   把环拆成链、并复制为两份即可
*   例如A->B->C ... A三角环，可以拆成A->B->C->A->B->C，只需注意遍历时只遍历3个元素即可

#### 单调队列优化

##### 以顺时针为例

*   定义s\[i] = p\[i] - d\[i],表示在i加油，跑到i+1
*   对s从1开始遍历操作，s\[i] += s\[i-1]，变为前缀和
*   例如从1开始出发，那么能够周游的条件就是既能到达2又能到达3、又能到达4...又能到达1+n（1+n就是回到1）
*   例如共有6个点，从2到4，油的变化量为s\[4] - s\[1]，2到5，变化量为s\[5] - s\[1]

    *   如果变化量为负，说明不能到达
    *   123456123456
    *   不难发现，如果能周游，那么s\[2]到s\[8]中的最小值减去s\[1]应不为负
    *   由此，发现可利用单调队列获得一段区间内的最小值

## 题解

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 2e6 + 10;

int n;
int o[N], d[N];
long long s[N];
int q[N];
bool ans[N];



int main() {
    cin >> n;

    for (int i = 1; i <= n; ++i)
        cin >> o[i] >> d[i];

    //顺时针
    //s[i]：在第i点加油，并走完i到i+1之间的路程后增加（减少）的油量
    for (int i = 1; i <= n; ++i)
        s[i] = s[i + n] = o[i] - d[i];

    //（i > j）s[i] - s[j]：从j+1加油出发，到i加油并走完i到i+1之间的路程后增加（减少）的油量
    //注意s[j]包括了j点的加油与j到j+1之间的路程，所以减去s[j]后的值是从j+1出发
    for (int i = 1; i <= n * 2; ++i)
        s[i] += s[i - 1];

    //单调队列初始为空
    int head = 0, tail = -1;

    //①对于第i个点，周游一周即到达第i+n个点
    //②当计算第1个点能否到达1+n时，需要使用从1到1+n中的s最小值，因此需要从后往前遍历
    //③对于第i个点，周游一圈油量变化为s[i + n - 1] - s[i - 1]
    //  要获取的是从i+n-1到i的s的最小值
    for (int i = n * 2; i; --i) {
        //由③分析可知，最多只用到i+n-1，i+n及以上的都删掉
        if (head <= tail && q[head] >= i + n)
            head++;

        //由③分析可知，考虑s最小值时需要包括s[i]
        //因此先加入单调队列，后计算是否安全
        while (head <= tail && s[q[tail]] >= s[i])
            tail--;

        q[++tail] = i;

        //计算是否安全
        if (i <= n && s[q[head]] - s[i - 1] >= 0)
            ans[i] = true;
    }

    //逆时针
    //s[i]：在第i个点加油，并走完i到i-1之间的路程后油量变化量
    //第n个点是第1个点的上一个点，第0个点也是第1个点的上一个点
    d[0] = d[n];

    for (int i = 1; i <= n; ++i)
        s[i] = s[i + n] = o[i] - d[i - 1];

    //(i > j) s[i] - s[j]：从第i个点加油开始，到第j+1个点加油并走完j+1到j之间的路程后油量变化量
    for (int i = 1; i <= n * 2; ++i)
        s[i] += s[i - 1];

    //单调队列为空
    head = 0, tail = -1;

    //①对于第n+i个点，周游一圈即到达第i个点
    //②当计算第n+1个点时，需要使用从1到n+1中的s最小值，因此从前往后遍历
    //③对于第n+i个点，周游一圈油量变化量为s[n + i] - s[i]
    //  要获取的是从n+i-1到i中s的最大值
    for (int i = 1; i <= n * 2; ++i) {
        //由③分析可知，对于n+i，最多只用到i，小于i的全删掉
        if (head <= tail && q[head] < i - n)
            head++;

        //计算是否安全
        if (i > n && s[q[head]] - s[i] <= 0)
            ans[i - n] = true;

        //由③分析可知，对于第i个点计算时用不到s[i]
        //因此先计算是否安全，后加入单调队列
        while (head <= tail && s[q[tail]] <= s[i])
            tail--;

        q[++tail] = i;
    }

    for (int i = 1; i <= n; ++i) {
        if (ans[i])
            cout << "TAK" << endl;
        else
            cout << ("NIE") << endl;
    }

}
```

## 应用2：琪露诺

在幻想乡，琪露诺是以笨蛋闻名的冰之妖精。

某一天，琪露诺又在玩速冻青蛙，就是用冰把青蛙瞬间冻起来。但是这只青蛙比以往的要聪明许多，在琪露诺来之前就已经跑到了河的对岸。于是琪露诺决定到河岸去追青蛙。

小河可以看作一列格子依次编号为 ***0*** 到 ***N***，琪露诺只能从编号小的格子移动到编号大的格子。而且琪露诺按照一种特殊的方式进行移动，当她在格子 ***i*** 时，她只移动到区间 ***\[i+L,i+R]*** 中的任意一格。你问为什么她这么移动，这还不简单，因为她是笨蛋啊。

每一个格子都有一个冰冻指数 ***A\_i***，编号为 ***0*** 的格子冰冻指数为 ***0***。当琪露诺停留在那一格时就可以得到那一格的冰冻指数 ***A\_i***。琪露诺希望能够在到达对岸时，获取最大的冰冻指数，这样她才能狠狠地教训那只青蛙。

但是由于她实在是太笨了，所以她决定拜托你帮它决定怎样前进。

开始时，琪露诺在编号 ***0*** 的格子上，只要她下一步的位置编号大于 ***N*** 就算到达对岸。

## 输入格式

第一行三个正整数 ***N, L, R***。

第二行共 ***N+1*** 个整数，第 ***i*** 个数表示编号为 ***i-1*** 的格子的冰冻指数 ***A\_{i-1}***。

## 输出格式

一个整数，表示最大冰冻指数。

## 样例 #1

### 样例输入 #1

    5 2 3
    0 12 3 11 7 -2

### 样例输出 #1

    11

## 提示

对于 ***60%*** 的数据，***N <= 10^4***。

对于 ***100%*** 的数据，***N <= 2***** 10^5**\*，\*\*\*-10^3 <=  A\_i<= 10^3 \*\*\*，\*\*\*1 <= L <= R <= N \*\*\*。数据保证最终答案不超过 ***2^{31}-1***。

## 思路

#### 原始DP：

*   f\[i]：走到i时冰冻指数最大值
*   状态转移：f\[i] = freeze\[i] + f\[j]，( i - R <= j <= i - L)

#### 单调队列优化：

*   定义两个队列
*   一个单调队列用于获得f\[j]最大值
*   一个普通队列用于暂存元素，因为此题的区间范围不是i到i+xxx，而是i+yyy到i+xxx，
*   也就是说，遍历到i，然后遍历到i+1时，可能暂时用不上i，但i以后会被例如i+3用上，所以暂存

## 题解

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int N, L ,R;
const int MAXN = 2e5 + 10;
int freeze[MAXN];
//考虑最坏情况，似乎好像大概会爆int所以用了long long，但其实用int应该大概可能也能过
long long f[MAXN];

//单调队列
int q[MAXN];
int head = 0, tail = -1;

//普通队列
int qq[MAXN];
int hhead = 0, ttail = -1;

//将元素插入单调队列
void insert(int i) {
    while(head <= tail && f[q[tail]] <= f[i]) tail -= 1;
    q[++tail] = i;
}

int main() {
    cin >> N >> L >> R;
    for(int i = 0; i <= N; ++i) {
        cin >> freeze[i];
    }

	//利用单调队列是否为空来判断i点能否到达，所以把0加入暂存队列，给L点用
    qq[++ttail] = 0;
	//从L点开始遍历，因为1到L-1都无法到达
    for(int i = L; i <= N; ++i) {
		//如果暂存队列的头元素符合区间范围，就加入单调队列
        if(hhead <= ttail && qq[hhead] <= i - L) insert(qq[hhead++]);
		//删掉单调队列中超过区间范围的元素
        if(head <= tail && q[head] < i - R) head++;
        qq[++ttail] = i;
		//如果单调队列不为空，说明有符合区间范围的元素，说明i点可以到达
        if(head <= tail) f[i] = freeze[i] + f[q[head]];
		//否则i点不能到达，设为极小值
        else f[i] = -1e9;
    }
	//注意题目对“到达对岸”的定义
    long long res = -1e9;
    for(int i = N - R + 1; i <= N; ++i) {
        res = max(res, f[i]);
    }

    cout << res;
}
```



