---
layout:     post
title:      "线性DP：花店橱窗布置"
subtitle:   ""
date:       2024-09-08 17:00:00
author:     "西米屋花火"
catalog: true
header-mask: 0.5
tags:
    - 动态规划
    - 线性DP
    - 算法
---

## 题目描述

某花店现有 ***F*** 束花，每一束花的品种都不一样。至少有同样数量的花瓶，被按顺序摆成一行。花瓶的位置是固定的，从左到右按 ***1\~ V*** 顺序编号，***V*** 是花瓶的数目。

花束可以移动，并且每束花用 ***1\~ F*** 的整数标识。所有花束在放入花瓶时必须保持其标识数的顺序。例如，假设杜鹃花的标识数为 ***1***，秋海棠的标识数为 ***2***，康乃馨的标识数为 ***3***，即杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。每个花瓶只能放一束花。

每个花瓶的形状和颜色也不相同，因此，当各个花瓶中放入不同的花束时，会产生不同的美学效果，并以美学值（一个整数 ***a\_{i,j}***）来表示，空置花瓶的美学值为 ***0***。在上述的例子中，花瓶与花束的不同搭配所具有的美学值，可以用如下的表格来表示：

|     | 花瓶 1      | 花瓶 2     | 花瓶 3     | 花瓶 4      | 花瓶 5     |
| --- | --------- | -------- | -------- | --------- | -------- |
| 杜鹃花 | ***7***   | ***23*** | ***-5*** | ***-24*** | ***16*** |
| 秋海棠 | ***5***   | ***21*** | ***-4*** | ***10***  | ***23*** |
| 康乃馨 | ***-21*** | ***5***  | ***-4*** | ***-20*** | ***20*** |

根据表格，杜鹃花放在花瓶 ***2*** 中，会显得非常好看，但若放在花瓶 ***4*** 中，则显得很难看。

为了取得最佳的美学效果，必须在保持花束顺序的前提下，使花的摆放取得最大的美学值，如果具有最大美学值的摆放方式不止一种，则输出任何一种方案即可。

## 输入格式

输入文件的第一行是两个整数 ***F*** 和 ***V***，分别为花束数和花瓶数。

接下来是矩阵 ***a\_{i,j}***，共 ***F*** 行，每行 ***V*** 个整数，***a\_{i,j}*** 表示花束 ***i*** 摆放在花瓶 ***j*** 中的美学值。

## 输出格式

输出文件的第一行是一个整数，为最大的美学值；接下来一行 ***F*** 个整数，为那束花放入那个花瓶的编号。

## 样例 #1

### 样例输入 #1

    3 5
    7 23 -5 -24 16
    5 21 -4 10 23
    -21 5 -4 -20 20

### 样例输出 #1

    53
    2 4 5

## 提示

对于 ***100%*** 的数据，***1<= F<= V<= 100***。

感谢 @罗恺 提供 SPJ

## 思路

*   f\[i]\[j]:考虑第1到i束花，第i束花插到第j个花瓶的情况下，最大美学值
*   f\[i]\[j] = max(f\[i-1]\[1], f\[i-1]\[2]...f\[i-1]\[j-1]) + beauty\[i]\[j]

## 题解

不难发现，可以使用滚动数组降维

```cpp
#include <iostream>
using namespace std;

int F, V;
const int MAXN = 110;
//f[i][j]:考虑第1到i束花，第i束花插到第j个花瓶的情况下，最大美学值
int f[2][MAXN];
int pre[MAXN][MAXN];
int beauty[MAXN][MAXN];

int q[MAXN];
int tail = -1;

void add_q(int i) {
    q[++tail] = i;
}

int main() {
    cin >> F >> V;

    for(int i = 1; i <= F; ++i) {
        for(int j = 1; j <= V; ++j) {
            cin >> beauty[i][j];
        }
    }
    //题目对于某个花能不能摆放没有说的很明白，但是
    //”即杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。每个花瓶只能放一束花。“
    //只能理解为每朵花都要插到一个花瓶里
    //所以插到0号花瓶就是没插，但不可能没插，设为极小值表示不可能
    f[1][0] = -1 * 0x3f3f3f3f;
    f[0][0] = -1 * 0x3f3f3f3f;

    //当i=1时，选了哪个花瓶，f就是多少
    for(int j = 1; j <= V; ++j) f[1][j] = beauty[1][j];

    //滚动数组的下标
    bool idx = 0;

    for(int i = 2; i <= F; ++i, idx ^= 1) {
        for(int j = 1; j <= V; ++j) {
            f[idx][j] = -1 * 0x3f3f3f3f;
            for(int p = j - 1; p >= 0; --p) {
                if(f[idx][j] < f[!idx][p]) {
                    pre[i][j] = p;
                    f[idx][j] = f[!idx][p];
                }
            }
            f[idx][j] += beauty[i][j];
        }
    }
    idx ^= 1;
    int res = -1 * 0x3f3f3f3f;
    int best_i;
    for(int i = 1; i <= V; ++i) {
        if(res < f[idx][i]) {
            best_i = i;
            res = f[idx][i];
        }
    }
    cout << res << endl;

    //利用队列获得期望的输出顺序
    add_q(best_i);
    int p = pre[F][best_i];
    add_q(p);
    for(int i = F - 1; i >= 2; --i) {
        p = pre[i][p];
        add_q(p);
    }

    for(int i = tail; i >= 0; --i) {
        cout << q[i] << " ";
    }

}
```

