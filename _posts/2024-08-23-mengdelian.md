---
layout:     post
title:      "状态压缩DP：蒙德里安的梦想"
subtitle:   ""
date:       2024-08-23 22:40:00
author:     "西米屋花火"
catalog: true
header-img: "img/post-nana.jpg"
header-mask: 0.5
tags:
    - 动态规划
    - 状态压缩DP
    - 算法
---
## 题面

求把 ***N \* M*** 的棋盘分割成若干个 ***1 \* 2*** 的长方形，有多少种方案。

例如当 ***N=2，M=4*** 时，共有 ***5*** 种方案。当 ***N=2，M=3*** 时，共有 ***3*** 种方案。

如下图所示：

![2411\_1.jpg](https://pub-2cdda6f679704f75bf34b7caab2ad90c.r2.dev/%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3.png)

## 输入格式

        输入包含多组测试用例。

每组测试用例占一行，包含两个整数 ***N*** 和 ***M***。

当输入用例 ***N=0，M=0*** 时，表示输入终止，且该用例无需处理。

## 输出格式

        每个测试用例输出一个结果，每个结果占一行。

## 数据范围

        1 <= N,M <= 11

## 输入样例：

```
1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0

```

## 输出样例：

```
1
0
1
2
3
5
144
51205

```

## 思路

#### 集合划分

*   f\[i]\[j]：第i列的摆放情况为j时的情况个数

#### 状态转移

*   f\[i]\[j] += f\[i-1]\[k]，k表示所有合法的第i-1列的拜访情况

## 题解

```cpp
#include <iostream>
#include <cstring>
using namespace std;

//一旦横着放的被确定，竖着放的也就被确定
//因此只考虑横着放的情况有多少

//定义区分：
//摆放情况：只考虑当前第i列，不考虑i-1列延申的
//格子占用情况：由第i-1列延申而来的与第i列摆放的合起来

//题目中M、N<=11
const int MAXN = 12;
//MAXNN的值是2的12次方，状态压缩，即利用bit来存储每列的格子占用情况
//MAXNN = 1000000000000（二进制）
//例如某一列：开关开开关，转为二进制数10110，十进制数22
const int MAXNN = 1 << MAXN;

//f[i][j]：第i列的摆放情况为j（利用二进制数存储），可能的情况有多少
//对“摆放情况”的定义：j不是上一列延申而来的，j会延申到下一列
long long f[MAXN][MAXNN];

//预处理，下标是格子占用情况的二进制数压缩形态，不能出现奇数个连续空出的格子（竖着必然放不了）
bool is_legal[MAXNN];

//题目中的N、M
int n, m;

int main() {
    while(cin >> n >> m, n || m) {

        //先预处理出合法的格子占用情况
        for(int i = 0; i < 1 << n; ++i) {
            is_legal[i] = true;
            int cnt = 0;
            for(int j = 0; j < n; ++j) {
                if(i >> j & 1) {
                    if(cnt & 1) {
                        is_legal[i] = false;
                        break;
                    }
                }
                else ++cnt;
            }
            if(cnt & 1) is_legal[i] = false;
        }

        //初始化f[][]
        memset(f, 0, sizeof f);
        //从第1列开始算，由于状态转移会用到第0列，而第0列不可能摆放
        //因此f[0][非0]=0
        f[0][0] = 1;

        //i:第i列
        for(int i = 1; i <= m; ++i) {
            //j:第i列的摆放情况的二进制数压缩形态
            for(int j = 0; j < 1 << n; ++j) {
                //k：第i-1列的摆放情况
                for(int k = 0; k < 1 << n; ++k) {
                    //j&k=0，即不可能i-1列放了，i列又放
                    //因为i-1列如果放了，就会延申到第i列

                    //j|k，即i-1列延申而来的与第i列放的合起来就是第i列的格子占用情况
                    if((j & k) == 0 && is_legal[j | k]) {
                        f[i][j] += f[i - 1][k];
                    }
                }
            }
        }

        cout << f[m][0] << endl;
    }

}
```

