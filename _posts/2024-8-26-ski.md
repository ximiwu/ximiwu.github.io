---
layout:     post
title:      "记忆化搜素：[SHOI2002] 滑雪"
subtitle:   ""
date:       2024-8-26 16:00:00
author:     "西米屋花火"
catalog: true
header-img: "img/post-nana.jpg"
header-mask: 0.5
tags:
    - 动态规划
    - 记忆化搜索
    - 算法
---

## 题目描述

Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：

```plain
1   2   3   4   5
16  17  18  19  6
15  24  25  20  7
14  23  22  21  8
13  12  11  10  9
```

一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 ***24-17-16-1***（从 ***24*** 开始，在 ***1*** 结束）。当然    ***25***－***24***－***23***－***...***－***3***－***2***－***1*** 更长。事实上，这是最长的一条。

## 输入格式

输入的第一行为表示区域的二维数组的行数 ***R*** 和列数 ***C***。下面是 ***R*** 行，每行有 ***C*** 个数，代表高度(两个数字之间用 ***1*** 个空格间隔)。

## 输出格式

输出区域中最长滑坡的长度。

## 样例 #1

### 样例输入 #1

    5 5
    1 2 3 4 5
    16 17 18 19 6
    15 24 25 20 7
    14 23 22 21 8
    13 12 11 10 9

### 样例输出 #1

    25

## 提示

对于 ***100%*** 的数据，***1<= R,C<= 100***。

## 题解

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

int r, c;
int map[110][110];
int f[110][110];
int res;

//dx,dy合起来是向量，代表上左下右的坐标偏移量
int dx[] = {0, -1, 0, 1};
int dy[] = {1, 0, -1, 0};

//返回f[x][y]
int dp(int x, int y) {
    //如果算过，直接返回（DP的精髓）
    if(f[x][y] != -1) return f[x][y];
    //如果没算过，算一下,最少距离也有1
    f[x][y] = 1;
    //枚举上左下右四种可能的走法
    for(int i = 0; i < 4; ++i) {
        //计算移动后的新坐标
        int a = x + dx[i];
        int b = y + dy[i];
        //判断新坐标是否合法：在边界内、高度从高到低
        if(a >= 1 && a <= c && b >= 1 && b <= r && map[a][b] < map[x][y]) {
            //状态转移方程
            f[x][y] = max(f[x][y], dp(a, b) + 1);
        }
    }
    return f[x][y];

}

int main() {
    //没计算过就是-1
    memset(f, -1, sizeof f);
    cin >> r >> c;
    for(int i = 1; i <= r; ++i) {
        for(int j = 1; j <= c; ++j) {
            cin >> map[j][i];
        }
    }
    //枚举不同起点
    for(int i = 1; i <= r; ++i) {
        for(int j = 1; j <= c; ++j) {
            res = max(res, dp(j, i));
        }
    }
    cout << res;

}
```

