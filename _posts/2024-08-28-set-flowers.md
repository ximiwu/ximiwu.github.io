---
layout:     post
title:      "多重背包问题：[NOIP2012 普及组] 摆花"
subtitle:   ""
date:       2024-08-28 02:30:00
author:     "西米屋花火"
catalog: true
header-img: "img/post-nana.jpg"
header-mask: 0.5
tags:
    - 动态规划
    - 多重背包问题
    - 算法
---

## 题目描述

小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 ***m*** 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 ***n*** 种花，从 ***1*** 到 ***n*** 标号。为了在门口展出更多种花，规定第 ***i*** 种花不能超过 ***a\_i*** 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。

试编程计算，一共有多少种不同的摆花方案。

## 输入格式

第一行包含两个正整数 ***n*** 和 ***m***，中间用一个空格隔开。

第二行有 ***n*** 个整数，每两个整数之间用一个空格隔开，依次表示 ***a\_1,a\_2, ... ,a\_n***。

## 输出格式

一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 ***10^6+7*** 取模的结果。

## 样例 #1

### 样例输入 #1

    2 4
    3 2

### 样例输出 #1

    2

## 提示

【数据范围】

对于 ***20%*** 数据，有 ***0\<n <= 8,0\<m <= 8,0 <= a\_i <= 8***。

对于 ***50%*** 数据，有 ***0\<n <= 20,0\<m <= 20,0 <= a\_i <= 20***。

对于 ***100%*** 数据，有 ***0\<n <= 100,0\<m <= 100,0 <= a\_i <= 100***。

NOIP 2012 普及组 第三题

## 思路

*   类似：多重背包问题
*   区别：要求的是情况总数，而非价值最值，且每个物品价值相同

## 误区

*   不能使用二进制优化，二进制优化在多重背包中只能用于求最值
*   原因：例如一种花有4个，拆成1、2、1，选择前两个和选择后两个成为不同的选法，然而实际上都是选了3朵，同一种情况被记为多次

## 题解

#### 二维

```cpp
#include <iostream>
using namespace std;

int n, m;
const int mod = 1e6 + 7;
const int MAXN = 110;

int a[MAXN];

//f[i][j]：只考虑前i种花，摆了j盆
int f[MAXN][MAXN];

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; ++i) {
        cin >> a[i];
    }

    //处理边界情况，当摆了0盆时，只有一种情况
    //注意从i = 0开始循环，当i=1时会用到i=0
    for(int i = 0; i <= n; ++i) {
        f[i][0] = 1;
    }


    for(int i = 1; i <= n; ++i) {
        for(int j = 1; j <= m; ++j) {

            //对于第i种花，枚举摆了几盆
            for(int k = 0; k <= a[i] && k <= j; ++k) {
                f[i][j] += f[i - 1][j - k] % mod;
            }
        }
    }

    cout << f[n][m] % mod;


}
```

#### 优化为一维

```cpp
#include <iostream>
using namespace std;

int n, m;
const int mod = 1e6 + 7;
const int MAXN = 110;

int a[MAXN];
//f[j]：摆了j盆
int f[MAXN];

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; ++i) {
        cin >> a[i];
    }

    //处理边界情况，当摆了0盆时，只有一种情况
    f[0] = 1;

    for(int i = 1; i <= n; ++i) {
		//与板子题一样，一维需要倒序枚举j，因为少了一个维度i
        for(int j = m; j >= 1; --j) {
            //注意，二维k从0开始枚举，一维k从1开始枚举
            //一维k=0时，f[j] += f[j]与二维形式不等价
            //二维：等式左边是第i层，右边是i-1层
            //一维：k=0时，等式左右两边都是第i层，因此不等价
            for(int k = 1; k <= a[i] && k <= j; ++k) {
                f[j] += f[j - k] % mod;
                //真的很抽象一定得反复取模不然就爆int真的很抽象
                f[j] = f[j] % mod;
            }
        }
    }

    cout << f[m] % mod;


}
```

