---
layout:     post
title:      "线性DP：大师"
subtitle:   ""
date:       2024-09-05 12:00:00
author:     "西米屋花火"

catalog: true
header-img: "img/post-nana.jpg"
header-mask: 0.5
tags:
    - 动态规划
    - 线性DP
    - 算法
---

## 题目背景

建筑大师最近在跟着数学大师 ljt12138 学数学，今天他学了等差数列，ljt12138 决定给他留一道练习题。

## 题目描述

ljt12138 首先建了 ***n*** 个特斯拉电磁塔，这些电塔排成一排，从左到右依次标号为 ***1*** 到 ***n***，第 ***i*** 个电塔的高度为 ***h\[i]***。

建筑大师需要从中选出一些电塔，然后这些电塔就会缩到地下去。这时候，如果留在地上的电塔的高度，从左向右构成了一个等差数列，那么这个选择方案就会被认为是美观的。

建筑大师需要求出，一共有多少种美观的选择方案，答案模 ***998244353***。

注意，如果地上只留了一个或者两个电塔，那么这种方案也是美观的。地上没有电塔的方案被认为是不美观的。

同时也要注意，等差数列的公差也可以为负数。

## 输入格式

第一行一个正整数 ***n***。

第二行 ***n*** 个非负整数，第 ***i*** 个整数是第 ***i*** 个电塔的高度 ***h\[i]***。

## 输出格式

输出一个整数，表示美观的方案数模 ***998244353*** 的值。

## 样例 #1

### 样例输入 #1

    8
    13 14 6 20 27 34 34 41

### 样例输出 #1

    50

## 样例 #2

### 样例输入 #2

    100
    90 1004 171 99 1835 108 81 117 141 126 135 144 81 153 193 81 962 162 1493 171 1780 864 297 180 532 1781 189 1059 198 333 1593 824 207 1877 216 270 225 1131 336 1875 362 234 81 288 1550 243 463 1755 252 406 261 270 279 288 1393 261 1263 297 135 333 872 234 881 180 198 81 225 306 180 90 315 81 81 198 252 81 297 1336 1140 1238 81 198 297 661 81 1372 469 1132 81 126 324 333 342 81 351 481 279 1770 1225 549

### 样例输出 #2

    11153

## 提示

设 ***v*** 为最高的电塔高度。

对于前 ***30%*** 的数据，\*\*\*n <= 20 \*\*\*。

对于前 ***60%*** 的数据，***n <= 100***，***v <= 2 \* 10^3***。

对于另外 ***20%*** 的数据，所有电塔的高度构成一个等差数列。

对于 ***100%*** 的数据，***n <= 10^3***，***v <=2 \* 10^4***。

## 思路

*   遍历所有建筑（记为i），对于i，遍历所有编号小于i的建筑（记为k），由h\[i]-h\[k]可得公差（记为d）
*   i就是当前等差数列最后一个数，k就是当前等差数列倒数第二个数
*   如果对于k为结尾的数列是以d为公差的等差数列，那么结尾再加上i，仍然是一个等差数列
*   也即f\[i]\[delta] = f\[k]\[delta] + 1，多加的1是i与k两个数构成的数列

## 题解

```cpp
#include <iostream>
using namespace std;

int n;
const int MAXN = 1e3 + 10;
const int MOD = 998244353;

int h[MAXN];

const int MAXNN = 4e4 + 100;
int f[MAXN][MAXNN];

int main() {
    cin >> n;
    for(int i = 1; i <= n; ++ i) {
        cin >> h[i];
    }
    
    //对于所有建筑，自己一个就可以构成一个数列
    int res = n;
    for(int i = 1; i <= n; ++i) {
        for(int j = i - 1; j >= 1; --j) {
            int delta = h[i] - h[j];
            if(delta < 0) delta += 4e4 + 50;
            //因为可能出现相同高度的建筑，同一个f会被加多次
            f[i][delta] += f[j][delta] + 1;
            f[i][delta] %= MOD;
            //注意，f[i]是给后面的i层用的，加res时不能直接用f
            //因为可能出现相同高度的建筑，同一个f会被加多次
            //例如13. 14 6 20. 27. 34 34. 41.
            //i=8时，f[8][7]先变成4，再变成8，因为有两个34
            //res应该加两次4，而不是先加4后加8
            res += f[j][delta] + 1;
            res %= MOD;
        }
    }

    cout << res;

}
```

